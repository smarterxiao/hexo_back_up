---
title: kotlin学习
date: 2018-05-06 23:46:10
tags: kotlin
---

> 这个是kotlin的学习笔记，kotlin成为android开发第一语言快一年了，现在才看是学习，感觉有点晚。书名是kotlin实战
# 1. kotlin的定义和目的
> 这一章简单带过
## 1.1 kotlin初体验
先来一个简单的例子

```
data class Person(val  name:String,val age:Int?=null)
fun main(args: Array<String>) {
    val persons= listOf<Person>(Person("alice"),Person("Bob",age=29))
    val oldest=persons.maxBy { it.age?:0 }
    println("The oldest is: $oldest")
}
```
运行的输出结果是

```
The oldest is: Person(name=Bob, age=29)
```
来解释一下这段代码的意思。这里申明了简答的数据类，他包括了两个属性：name和age。age属性默认为null（如果没有指定），在创建person的列表时，省略了alice的年龄，所以这里的年龄使用的是默认值null，然后你调用了maxBy函数来查找列表中你年纪最大的那个的那个人，传递给这个函数的是一个lambda表达式需要一个参数，使用it作为这个参数的默认名称，如果age属性为null，elvis运算符（？：）会返回零，因为alice的年龄没有指定，elvis运算符使用0来替代他，所以bob就成了年龄最大的人
感觉不错
## 1.2 kotlin的主要特征
### 1.2.1 目标平台：服务器端，android和任何java运行的地方
kotlin的首要目标是提供一种更加简洁、高效、安全的替代java的语言，并适用于现在所有的java环境

### 1.2.2静态类型
kotlin和java一样是一种静态类型的编程语言，这意味着所有表达式的类型在编译期已经确定，而编译器就能验证对象是否包含了你想访问的方法或者字段
这个和动态类型语言形成了鲜明的对比，groovy是动态的。这些语言允许你定义可以存储任何数据类型的变量。
另外kotlin不需要你明确的申明每个变量的类型。
```
val x=1
```
在申明变量的时候，由于变量初始化为整形值，kotlin自动判断出他的类型是int，这个和java不同

### 1.2.3 函数式和面向对象
支持lambda
# 2. kotlin基础
## 2.1 基本要素：函数和变量
### 2.1.1 Hello,World!
我们从一个最经典的例子Hello,World讲解一下kotlin的用法，这个功能在kotlin中只需要一个函数就能够实现

```
fun main(args: Array<String>) {
    println("Hello,world!")
}
```
可以从这样简单的代码中看到一些kotlin的特性

* 关键词fun用来声明一个函数，没错，kotlin编程有很多乐趣（fun）
* 参数的类型卸载它的名称后面，稍后就可以看到，变量的声明也是这样的
* 函数可以定义在文件的最外层，不需要把他放在类中
* 数组就是类。和Java不同，Kotlin没有声明数组类型的特殊语法
* 使用println替代了System.out.println。kotlin标准库给java标准库提供了很多语法简单的包装，而println就是其中一个
* 和许多其他现代化语言一样，可以省略每行代码结尾的分号

### 2.1.2 函数
你已经可以看到怎么样声明一个没有返回任何东西的函数，但是如果函数有一个有意义的结果，返回类型应该放在那里呢，你可能会猜到他对应位于参数列表之后的某处：

```
fun main(args: Array<String>) {
    println(max(1,2))
}
fun  max(a:Int,b:Int):Int{
    return if (a>b)a else b
}
```

看一下输出结果
```
2
```


函数的声明以fun关键字开始，函数名称紧随其后：这个例子中函数名称是max，接下来是括号起来的参数列表，参数列表的后面跟着返回类型，他们之间用一个冒号隔开


```
//fun  函数名称(参数列表):返回值类型
fun  max(a:Int,b:Int):Int{
    return if (a>b)a else b//函数体
}
```
语句和表达式：
在kotlin中，if是表达式，而不是语句。语句和表达式的区别在于，表达式有值，并能作为另外一个表达式的一部分使用；而语句总是包围着它的代码中顶层元素，并且没有自己的值。在java中，所有的控制结构都是语句。而在kotlin中，除了循环（for、do和do/while）以外大多数的控制结构都是表达式。这种结合控制结构和其他表达式的能力能让你可以简明扼要的表示许多常见的模式，稍后你会在本书中看到这些内容。
另一方面，java中的复制操作是表达式，在kotlin中反而变成了语句。这有助于避免比较和赋值之间的混淆，而这种混淆是常见的错误来源。

表达式函数体
可以让前面的函数变得更简单。因为他的函数体是由单个表达式构成的，可以用这个表达式作为完整的函数体，并去掉花括号和return语句：
```
fun  max(a:Int,b:Int):Int = if (a>b)a else b
```

如果函数体写在花括号中，我们说这个函数有代码块体。如果他直接返回一个表达式，它就有表达式体
在kotlin代码中常常会看到表达式个体函数，这种风格不光用在一些简单的单行函数中，也会用在对更加复杂的单个表达式就只的函数中，比如if，when，try。这个可以在后面看到
当然还可以对max函数进一步简化

```
fun  max(a:Int,b:Int) = if (a>b)a else b

```
为什么有些函数可以不声明返回类型？作为一门静态类型语言，kotlin不是要求每一个表达式都应该在编译器有返回类型吗？事实上，每一个变量和表达式都有类型，每一个函数都有返回类型。但是作为对表达式体函数来说，编译器会分析作为函数体的表达式，并把他的类型作为函数的返回类型，即使没有显示的写出来。这就是 *类型推导*
kotlin中只有表达式体函数的返回类型可以省略，队友有返回值的代码块体函数，必须显示地写出返回类型和return语句。这个是可以的选择。真实项目中的函数一般很长且可以包含多个return语句，显示地写出返回类型和return语句能帮助你快速的理解函数能返回什么。

### 2.1.3 变量

在java中声明变量的时候回从类型开始，在kotlin中这样是不行的，应为许多变量声明的类型都是可以省略。所以在kotlin中以关键字开始，然后是变量名称，最后可以加上类型（不加也可以）
```
val question="红烧鸡翅膀，我最喜欢吃"
val answer=250
```
这个例子省略了类型声明，但是如果需要也可以显示的指明变量的类型：
```
val question:String="红烧鸡翅膀，我最喜欢吃"
```
和表达式体函数一样，如果不指定类型，编译器会分析初始化器表达式的值，并把它的类型作为变量的类型，在前面这个例子中，变量的初始化器是Int类型，那么变量就是这个类型
如果你使用浮点数常量，那么变量就是double类型：
···
val yearsToCompute=3.4e6
···
后面更加深入的介绍算数类型
如果变量没有初始化器，就需要显示的指定他的类型

```
    val answer:Int
    answer=100
```
但是这个只能在方法内部有效
如果不能提供付给这个变量值得信息，编译器就无法推断出它的类型
可变变量和不可变变量
* val(value)不可变，对应java的final
* var(variable)可变

默然情况下，应该尽可能的使用val关键词来修饰kotlin变量，仅在必要的时候换成var，使用不可变引用、不可变对象以及无副作用函数让代码更接近函数式编程风格。
在定义了val变量的代码执行期间，val只能进行唯一一次初始化。但是，如果编译器能确保只有唯一一条初始化语句会被执行，可以根据条件使用不同的值来初始化它

```

val message:String
if(true){
    message="Success"
}else{
    message="fail"
}

```

注意，尽管val引用自身是不可变的，但是他指向的对象是可变的，例如

```
val language= arrayListOf("java")
language.add("kotlin")
```


即使var关键字允许改变自己的值，但是他的类型确实改变不了的，例如

```
var answer=43
answer="no answer"
```
使用字符串字面值会发生错误，因为他的类型是String不是期望的类型(Int)，编译器只会根据初始化器来推断变量的类型，在决定类型的时候不会考虑后续复赋值操作。
如果需要在变量中存储不匹配类型的值，必须手动把值转换或强转到正确的类型。后面会讨论基本数据类型之间的转换
### 2.1.4 更简单的字符串格式化：字符串模板
