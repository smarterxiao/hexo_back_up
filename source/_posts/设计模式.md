---
title: 设计模式
date: 2017-03-22 23:59:01
tags:
---

这个是读设计模式之禅的读书笔记

<!-- more -->

# 最重要的几个原则

# 设计模式开始前的准备

* 工具
* UML

# 3.单例模式
## 3.1 类图

![Alt text](/设计模式/diagram-3798961331217258717.png "Optional title")

## 3.2一个简单的例子
* 皇帝是一个只有一个，是单例
```
public class Emperor {
    private  static final Emperor emperor=new Emperor();
    private  Emperor(){};
    public  static Emperor getIntence(){
        return emperor;
    }
    public static void say(){
        System.out.println("我是皇帝xxx");
    }

}
```
* 臣子可以有多个，臣子朝拜皇帝

```
public class Minister {
    public static void main(String[] args) {
        for (int i = 0; i < 30; i++) {
            Emperor emperor=Emperor.getIntence();
            emperor.say();
        }
    }
}
```

## 3.3 单例模式的应用
### 3.3.1 优点
* 节约内存
* 资源共享

### 3.3.2 缺点
* 拓展困难
* 单例模式和单一职责原则冲突

## 3.4 单例模式的注意事项
### 并发问题
* 饿汉试
> 实现创建好，只要get就可以,下面就是一个典型的饿汉式
```

public class Emperor {
  private static final Emperor emperor = new Emperor();
   //初始化 一个 皇帝 private Emperor(){
//世俗 和 道德 约束 你， 目的 就是 不 希望 产生 第二个 皇帝
}
  public static Emperor getInstance(){
   return emperor;
  }
   //皇帝 发话 了
  public static void say(){
  System. out. println(" 我 就是 皇帝 某 某某....");
    }
}

```

* 懒汉式
> 用的时候创建，会发生多线程安全问题
```
public class Singleton {
   private static Singleton singleton = null;
    //限制 产生 多个 对象
     private Singleton(){
}
//通过 该 方法 获得 实例 对象
 public static Singleton getSingleton(){
   if( singleton == null){
      singleton = new Singleton();
      }
    return singleton;
    }
}

```

* 解决办法：
  * 使用饿汉式
  * 使用synchronized

## 3.5 单例模式的拓展
### 3.5.1 一个国家有两个皇帝
> 明朝的明英宗朱祁镇和他弟弟明景帝，弟弟忘了让哥哥当太上皇...(⊙o⊙)哦。出现了一国两个主人的情况。皇帝不是什么人想当就能当的，所以这个就是这个对象只可以创建两次，这个怎么处理。

### 3.5.2 类图

![这个是UML图](/设计模式/diagram-8826285099454707507.png)

### 3.5.3 代码
* 皇帝

```
public class Emperor2 {
    //只有两个皇帝
    public static int maxSizeOfEmperor = 2;
    //创建一个集合用于存储两个皇帝,每个皇帝都有独一无二的名字
    private static ArrayList<Emperor2> emperor2s = new ArrayList<>();
    //创建当前皇帝的名称
    private static ArrayList<String> names = new ArrayList<>();
    //当前皇帝的数量
    private static int size = 0;


    static {

        for (int i = 0; i < maxSizeOfEmperor; i++) {
            emperor2s.add(new Emperor2("皇家" + i + "号"));
        }

    }

    private static int countNumOfEmperor;


    private Emperor2(String name) {
        names.add(name);
    }


    private Emperor2() {
    }

//随机 获得 一个 皇帝 对象
    public static Emperor2 getInstance() {
        Random random = new Random();
        //随机 拉出 一个 皇帝， 只要 是个 精神 领袖 就成
        countNumOfEmperor = random.nextInt(maxSizeOfEmperor);
        return emperor2s.get(countNumOfEmperor);
    }

    // 皇帝 发话 了
    public static void say() {
        System.out.println(names.get(countNumOfEmperor));
    }
}
```

* 臣子
> 没有什么变化

```
public class Minister {
    public static void main(String[] args) {
        for (int i = 0; i < 30; i++) {
            Emperor emperor=Emperor.getIntence();
            //为了更加清晰，加入这个：
            System. out. print(" 第"+( i+ 1)+" 个大 臣 参拜 的 是：");
            emperor.say();
        }
    }
}
```

* 结果
```
第 1 个大 臣 参拜 的 是： 皇 1 帝
第 2 个大 臣 参拜 的 是： 皇 2 帝
第 3 个大 臣 参拜 的 是： 皇 1 帝
第 4 个大 臣 参拜 的 是： 皇 1 帝
第 5 个大 臣 参拜 的 是： 皇 2 帝
```


# 4.工厂方法模式
